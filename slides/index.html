<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- <link rel="icon" type="image/svg+xml" href="/vite.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fagkveld i Go</title>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Fagkveld i Go</h1>
          <pre>
            <code data-trim data-noescape class="language-golang">
              func main() {
                  fmt.Println("Hello, world!")
              }
            </code>
          </pre>
        </section>

        <section>
          <h2>Agenda</h2>
          <ul>
            <li>Intro</li>
            <li>Liten gjennomgang av språket</li>
            <li>Hva <i>kan</i> vi gjøre i Go?</li>
            <li>Når <i>bør</i> vi bruke Go?</li>
            <li>Performance</li>
            <hr />
            <li>Oppsett av Go</li>
            <li>Ressurser</li>
          </ul>
        </section>

        <section>
          <h2>Intro</h2>
          <section>
            <ul>
              <li>Startet hos Google av Robert Griesemer, Rob Pike og Ken Thompson</li>
              <li>Design påbegynt 2007, annonsert offentlig 2009, v1.0 i 2012</li>
              <li>Go er
                <ul>
                  <li>statically typed</li>
                  <li>simple/easy to learn</li>
                  <li>built for concurrency</li>
                  <li>simple to deploy</li>
                </ul>
              </li>
            </ul>
          </section>
        </section>

        <!-- GJENNOMGANG -->
        <section>
          <h3>Liten gjennomgang av språket...</h3>
        </section>

        <section>
          <h3>Typesystem</h3>
        </section>
        <section>
          <section>
            <p>Typesystem: <b>funskjoner</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                func add(a int, b int) int {
                    return a + b
                }
              </code>
            </pre>
          </section>
          <section>
            <p>Typesystem: <b>structs</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                type operation struct {
                    a int
                    b int
                }
              </code>
            </pre>
          </section>
          <section>
            <p>Typesystem: <b>constructor finnes ikke</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                func newOperation(a int, b int) *operation {
                    return &operation{
                        a: a,
                        b: b,
                    }
                }
              </code>
            </pre>
            <p class="small">* = pointer</p>
            <p class="small">& = ta referanse</p>
          </section>
          <section>
            <p>Typesystem: <b>camelCase = unexported</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="1" class="language-golang">
                func newOperation(a int, b int) *operation {
                    return &operation{
                        a: a,
                        b: b,
                    }
                }
              </code>
            </pre>
            <p class="small">Unexported = kan bare brukes <b>internt</b> i en <b>package</b></p>
          </section>
          <section>
            <p>Typesystem: <b>PascalCase = exported</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="1" class="language-golang">
                func NewOperation(a int, b int) *operation {
                    return &operation{
                        a: a,
                        b: b,
                    }
                }
              </code>
            </pre>
            <p class="small">Exported = kan brukes av <b>eksterne</b> <b>packages</b></p>
          </section>
          <section>
            <p>Typesystem: <b>unexported struct, exported functions</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="1,13" class="language-golang">
                type operation struct {
                    a int
                    b int
                }

                func NewOperation(a int, b int) *operation {
                    return &operation{
                        a: a,
                        b: b,
                    }
                }

                func (o *operation) Add() int {
                    return o.a + o.b
                }
              </code>
            </pre>
            <p class="small"><b><code>operation.Add</code></b> kan brukes av eksterne, men feltene er skjulte</p>
          </section>
          <section>
            <p>Typesystem: <b>pointer receivers</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="8" class="language-golang">
                func NewOperation(a int, b int) *operation {
                    return &operation{
                        a: a,
                        b: b,
                    }
                }

                func (o *operation) Add() int {
                    return o.a + o.b
                }
              </code>
            </pre>
            <p class="small"><b><code>(o *operation)</code></b> kalles en <b>pointer</b> receiver</p>
            <p class="small"><b>Funskjoner</b> blir til <b>metoder</b> når de har en receiver</p>
          </section>
          <section>
            <p>Typesystem: <b>value receivers</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="8" class="language-golang">
                func NewOperation(a int, b int) *operation {
                    return &operation{
                        a: a,
                        b: b,
                    }
                }

                func (o operation) Add() int {
                    return o.a + o.b
                }
              </code>
            </pre>
            <p class="small"><b><code>(o operation)</code></b> kalles en <b>value</b> receiver</p>
            <p class="small"><b><code>Add</code></b> vil få en <b>kopi</b> av en <b><code>operation</code></b></p>
          </section>
          <section>
            <p>Typesystem: <b>interfaces</b></p>
            <pre class="sm">
              <code data-trim data-noescape data-line-numbers="1-6|8-13|15-23|*" class="language-golang">
                type Addition interface {
                    Add() int
                }
                type Subtraction interface {
                    Subtract() int
                }

                func (o *operation) Add() int {
                    return o.a + o.b
                }
                func (o *operation) Subtract() int {
                    return o.a - o.b
                }
                // --------------------------------
                // En annen package
                func main() {
                    op := interfaces.NewOperation(2, 1) // *operation
                    ComputeSumAndDiff(op, op)
                }

                // Interface type arguments er alltid pointers
                func ComputeSumAndDiff(o1 interfaces.Addition, o2 interfaces.Subtraction) (int, int) {
                    return o1.Add(), o2.Subtract()
                }
              </code>
            </pre>
            <p class="small">Implementasjon av interface er <b>implisitt</b></p>
            <p class="small">Interface som argument er en (fat - vtable) pointer (som kan være <b>nil</b>)</p>
          </section>
          <section>
            <p>Typesystem: <b>explicit interface implementasjon?</b></p>
            <pre class="sm">
              <code data-trim data-noescape data-line-numbers="15,16" class="language-golang">
                type Addition interface {
                    Add() int
                }
                type Subtraction interface {
                    Subtract() int
                }

                func (o *operation) Add() int {
                    return o.a + o.b
                }
                func (o *operation) Subtract() int {
                    return o.a - o.b
                }

                var _ Addition = (*operation)(nil)
                var _ Subtraction = (*operation)(nil)
              </code>
            </pre>
            <p class="small">Variabel i globalt scope med discard får compileren til å verifisere interface implementasjon</p>
          </section>
          <section>
            <p>Typesystem: <b>generics</b></p>
            <pre class="sm">
              <code data-trim data-noescape data-line-numbers class="language-golang">
                // This package is 0.0.0 - experimental
                import "golang.org/x/exp/constraints"

                type Number interface {
                    constraints.Integer | constraints.Float
                }

                type operation[T Number] struct {
                    a T
                    b T
                }

                func NewOperation[T Number](a T, b T) *operation[T] {
                    return &operation[T]{
                        a: a,
                        b: b,
                    }
                }
              </code>
            </pre>
            <p class="small">Generics ble introdusert i Go <b>1.18</b></p>
          </section>
          <section>
            <p>Typesystem: <b>generics</b></p>
            <pre class="md">
              <code data-trim data-noescape data-line-numbers data-ln-start-from="19" class="language-golang">
                // ...

                type Addition[T Number] interface {
                    Add() T
                }
                type Subtraction[T Number] interface {
                    Subtract() T
                }

                func (o *operation[T]) Add() T {
                    return o.a + o.b
                }
                func (o *operation[T]) Subtract() T {
                    return o.a - o.b
                }

                var _ Addition[int] = (*operation[int])(nil)
                var _ Subtraction[int] = (*operation[int])(nil)
              </code>
            </pre>
          </section>
          <section>
            <p>Typesystem: <b>generics</b></p>
            <pre class="md">
              <code data-trim data-noescape data-line-numbers class="language-golang">
                // ...
                // --------------------------------
                // En annen package
                func main() {
                    op := generics.NewOperation(2, 1) // *operation
                    ComputeSumAndDiff[int](op)        // second type parameter is inferred
                }

                // Addition og Subtraction blir "embedded" i AdditionAndSubtraction
                type AdditionAndSubtraction[T generics.Number] interface {
                    generics.Addition[T]
                    generics.Subtraction[T]
                }

                func ComputeSumAndDiff[T generics.Number, O AdditionAndSubtraction[T]](o O) (T, T) {
                    return o.Add(), o.Subtract()
                }
              </code>
            </pre>
            <p class="small">I motsetning til C#, kan compileren gjør delvis inference av generic type parameters</p>
          </section>
          <section>
            <p>Typesystem: <b>control flow</b></p>
            <div class="r-stack">
              <pre class="fragment fade-out" data-fragment-index="0">
                <code data-trim data-noescape data-line-numbers class="language-golang">
                  // if
                  if a > b {
                      return a
                  } else if a &lt; b {
                      return b
                  } else {
                      return 0
                  }

                  // switch
                  switch a {
                  case 1:
                      return "one"
                  case 2:
                      return "two"
                  default:
                      return "many"
                  }
                </code>
              </pre>
              <pre class="fragment current-visible" data-fragment-index="0">
                <code data-trim data-noescape data-line-numbers class="language-golang">
                  // for
                  for i := 0; i &lt; 10; i++ {
                      fmt.Println(i)
                  }
                  // infinite loop
                  for {

                  }
                  // range for loop
                  for i, v := range a {
                    fmt.Println("index: %d: value: %d", i, v)
                  }
                </code>
              </pre>
            </div>
          </section>
          <section>
            <p>Typesystem: <b>container types</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                // array - static size
                var a [5]int
                a[2] = 7

                // slice - dynamic size
                var s1 []int = a[1:4] // does not allocate
                s1 = append(s1, 2, 3, 4) // may allocate

                // different ways to create a slice
                var s2 = []int{0, 1, 2, 3, 4, 5}
                var s3 = make([]int, 3)

                // map
                m := make(map[string]int)
                m["k1"] = 7
                m["k2"] = 13
              </code>
            </pre>
          </section>
          <section>
            <p>Typesystem: <b>closures</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                // closure - function returning a function that captures a variable
                func adder() func(int) int {
                    sum := 0
                    return func(x int) int {
                        sum += x
                        return sum
                    }
                }
              </code>
            </pre>
          </section>
          <section>
            <p>Typesystem: <b>errors</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                // functions can return multiple values, commonly errors
                func f() (int, error) {
                    return 0, errors.New("f: error")
                }

                // errors are commonly wrapped by downstream errors
                func g() (int, error) {
                    n, err := f()
                    if err != nil {
                        return 0, fmt.Errorf("g: error: %w", err)
                    }
                    return n + 1, nil
                }
              </code>
            </pre>
            <p class="small">Errors er vanlig <b>values</b>, ingen stacktraces bygget inn</p>
            <p class="small">Flere verdier returneres som tuples. Disse er <i>ikke</i> unions</p>
            <p class="small">Ikke noe exceptions! bare panic's, som ikke skal skje</p>
          </section>
          <section data-transition="slide-in none-out">
            <p>Typesystem: <b>concurrency - goroutines</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                func f(from string) {
                    for i := 0; i &lt; 3; i++ {
                        fmt.Println(from, ":", i)
                    }
                }

                func main() {
                    f("direct")
                    go f("goroutine")

                    fmt.Println("done")
                }
              </code>
            </pre>
            <p class="small">En <b>goroutine</b> er en 'lightweight thread'</p>
            <p class="small">Her vil vi se 'direct' : 1-3, så done (ingenting fra 'goroutine')</p>
          </section>
          <section data-transition="none-in slide-out">
            <p>Typesystem: <b>concurrency - goroutines</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="11" class="language-golang">
                func f(from string) {
                    for i := 0; i &lt; 3; i++ {
                        fmt.Println(from, ":", i)
                    }
                }

                func main() {
                    f("direct")
                    go f("goroutine")

                    time.Sleep(time.Second * 1)
                    fmt.Println("done")
                }
              </code>
            </pre>
            <p class="small">Her vil vi også se logs fra 'goroutine'</p>
          </section>
          <section>
            <p>Typesystem: <b>concurrency - channels</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="*|5|6|7|2|8|*" class="language-golang">
                func f(c chan string) {
                    c &lt;- "ping"
                }
                func main() {
                    c := make(chan string)
                    go f(c)
                    msg := &lt;-c
                    fmt.Println(msg) // ping
                }
              </code>
            </pre>
            <p class="small">En channel er en FIFO kø, kan være <b>unbuffered</b> eller <b>buffered</b>. I dette tilfellet bruker vi <b>unbuffered</b></p>
          </section>
          <section>
            <p>Typesystem: <b>concurrency - channels</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="*|6" class="language-golang">
                func f(c chan string) {
                    c &lt;- "ping"
                }
                func main() {
                    c := make(chan string)
                    msg := &lt;-c // fatal error: all goroutines are asleep - deadlock!
                    go f(c)
                    fmt.Println(msg)
                }
              </code>
            </pre>
            <p class="small">Receive <b>blocker</b>, og ingen kan sende meldinger</p>
          </section>
          <section>
            <p>Typesystem: <b>concurrency - channels</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers="*|2" class="language-golang">
                func f(c chan string) {
                  c &lt;- "ping" // fatal error: all goroutines are asleep - deadlock!
                }
                func main() {
                  c := make(chan string)
                  f(c)
                  fmt.Println(&lt;-c)
                }
              </code>
            </pre>
            <p class="small">Send <b>blocker</b>, og ingen kan ta receive meldingen</p>
          </section>
          <section>
            <p>Typesystem: <b>concurrency - channels</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                func f(c chan string) {
                  c &lt;- "ping"
                }
                func main() {
                  c := make(chan string, 4)
                  f(c)
                  f(c)
                  f(c)
                  f(c)
                  fmt.Println(&lt;-c)
                  fmt.Println(&lt;-c)
                  fmt.Println(&lt;-c)
                  fmt.Println(&lt;-c)
                }
              </code>
            </pre>
            <p class="small">En <b>buffered</b> channel gjør send-operasjoner mulig før det er noen aktive receivers</p>
          </section>
          <section>
            <p>Typesystem: <b>defer</b></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                func SetPermissions() error {
                    f, err := os.Open("file.txt")
                    if err != nil {
                      return err
                    }
                    defer f.Close()
                    f.Chmod(0644)
                    f.Chown(0, 0)
                    return nil
                }
              </code>
            </pre>
            <p class="small"><b><code>f.Close()</code></b> vil kjøre rett før <b><code>return</code></b> statement</p>
          </section>
          <section>
            <h2>Typesystem - andre ting?</h2>
          </section>
        </section>
        <section>
          <h3>Concurrency</h3>
          <ul>
            <li>"Green" threads (goroutines) - M:N threading model</li>
            <li>"Coordinate by communicating" (les: channels)</li>
            <li>Lett å lage goroutine per subprossess/background worker/request/X</li>
            <hr />
            <li>goroutine vs Task/Promise</li>
            <li>Task.All / Promise.all ???</li>
            <li><a href="https://www.datadoghq.com/blog/engineering/introducing-glommio/" target="_blank">Thread-per-core arkitektur?</a></li>
          </ul>
        </section>
        <section>
          <h3>Compiler, runtime</h3>
          <ul>
            <li>gc - .go -> SSA (IL) -> machine code (x86-64, x86-32, arm)</li>
            <li>Statically linked (by default)</li>
            <li>Enkel syntax = rask compiler</li>
            <li>Low latency GC (litt værre på throughput)</li>
            <li>'What color is your function' - <b>løst!</b> (preemption)</li>
            <li>PGO i preview for 1.20</li>
            <li>Register-basert calling convention (siden 1.16)</li>
            <li>Liten overhead - 20-30mb vs 100mb i .NET (sist jeg testet)</li>
            <li>Rask startup (siden det er AOT)</li>
          </ul>
        </section>
        <section>
          <h3>Tooling</h3>
          <ul>
            <li>Flere lokale versjoner av go toolchain støttet (trenger ikke gvm)</li>
            <li>Package manager (go get)</li>
            <li>Test runner (go test)</li>
            <li>Test coverage (go test -cover)</li>
            <li>Doc generator (go doc)</li>
            <li>Benchmarking (go test -bench=)</li>
            <li>Profiling (go test -cpuprofile cpu.prof ...)</li>
            <li>Formatter (go fmt)</li>
            <li>Linter/static analysis (golint, go vet)</li>
            <hr />
            <li>VSCode med Go extension funker veldig bra</li>
          </ul>
        </section>
        <section>
          <h3>Build og deploy</h3>
          <ul>
            <li>Veldig lett</li>
          </ul>
          <pre>
            <code data-trim data-noescape data-line-numbers class="language-dockerfile">
              FROM golang:1.20 AS build
              RUN useradd -u 1001 -m todo-api

              WORKDIR /app

              # Fetch dependencies
              COPY go.mod go.sum ./
              RUN go mod download
              RUN go mod verify

              # Build API
              COPY . ./
              RUN CGO_ENABLED=0 GOOS=linux go build -o /api cmd/todo-api/main.go

              FROM scratch

              COPY --from=build /etc/passwd /etc/passwd
              USER 1001

              COPY --from=build /api /api

              EXPOSE 3000

              ENTRYPOINT ["/api"]
            </code>
          </pre>
        </section>
        <!-- /GJENNOMGANG -->

        <section>
          <h2>Hva <i>kan</i> eller <i>bør</i> vi utvikle i Go?</h2>
        </section>
        <section>
          <h3>CLI med <a href="https://github.com/charmbracelet/bubbletea" target="_blank">bubbletea</a></h3> <!-- TODO fix link -->
          <section>
            <div class="r-stack">
              <img class="fragment fade-in-then-out" src="https://github.com/charmbracelet/bubbletea/raw/master/examples/chat/chat.gif" />
              <img class="fragment fade-in-then-out" src="https://github.com/charmbracelet/bubbletea/raw/master/examples/package-manager/package-manager.gif" />
              <img class="fragment fade-in" src="https://github.com/charmbracelet/bubbletea/raw/master/examples/list-fancy/list-fancy.gif" />
            </div>
          </section>
          <section>
            <ul>
              <li>Lightweight, statically linked binaries</li>
              <li>Rask startup</li>
              <li>Bra biblioteker (spesielt i cloud-native/devops space)</li>
              <hr />
              <li>Go er veldig linux-centric</li>
              <li>I en .NET/JVM/X-sjappe har det ikke nødvendigvis noe for seg</li>
            </ul>
          </section>
        </section>
        <section>
          <h3>Cloud-native</h3>
          <section>
            <ul>
              <li>Platform-teams</li>
              <li>DevOps</li>
              <li>SRE</li>
              <li>Alt som er tett på containere, k8s</li>
              <hr />
              <li>Veldig bra økosystem</li>
              <li>Erstatter mye Python (omtrent like enkelt, men skalerer bedre)</li>
            </ul>
            <p class="fragment fade-up small">MEN - WASM anses av mange som "fremtiden" ift orkestrering og packaging, her er det mye Rust</p>
          </section>
          <section>
            <img src="cncf.png" />
          </section>
        </section>
        <section>
          <h3><b><a href="https://tinygo.org/" target="_blank">TinyGo</a></b></h3> <!-- TODO fix link -->
          <section>
            <img src="tinygo.png" />
          </section>
          <section>
            <ul>
              <li>LLVM compiler backend</li>
              <li>Custom runtime library (allocator, scheduler)</li>
              <hr />
              <li>Microcontrollers</li>
              <li>WASM/WASI</li>
              <li>C interop faktisk ikke krise</li>
              <li>Virker fortsatt ganske niche (WASM er ganske pointless foreløpig)</li>
            </ul>
          </section>
        </section>
        <section>
          <h3>Native apps (mobil)</h3>
          <section>
            <ul>
              <li><b>gobind</b> - language bindings for Java, Objective-C (Go SDKs/libraries)</li>
              <pre class="sm">
                <code data-trim data-noescape data-line-numbers class="language-bash">
                  $ go get -d golang.org/x/mobile/example/bind/...
                  ...
                  $ gomobile bind -o app/hello.aar -target=android golang.org/x/mobile/example/bind/hello
                </code>
              </pre>
              <hr />
              <li><b>gomobile</b> - native compilation</li>
              <pre class="sm">
                <code data-trim data-noescape data-line-numbers class="language-bash">
                  $ go get -d golang.org/x/mobile/example/basic
                  ...
                  $ gomobile build -target=android -androidapi 19 golang.org/x/mobile/example/basic
                </code>
              </pre>
              <p class="small">Usikkert om disse er well-maintained... (experimental)</p>
            </ul>
          </section>
          <section>
            <img src="fyne.png" />
          </section>
          <section>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-bash">
                $ fyne package -os android -appID com.example.myapp -icon mobileIcon.png
                $ fyne package -os ios -appID com.example.myapp -icon mobileIcon.png
              </code>
            </pre>
            <hr />
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-bash">
                $ adb install myapp.apk
                $ fyne package -os iossimulator -appID com.example.myapp -icon mobileIcon.png && \
                    xcrun simctl install booted myapp.app
              </code>
            </pre>
          </section>
        </section>
        <section>
          <h3>Backend development</h3>
          <section>
            <ul>
              <li>Rammeverk: gin, beego, fiber, echo, kit</li>
              <li>Routere: mux (archived), chi</li>
              <li>JSON: innebygd (field annotations)</li>
              <hr />
              <li>'Simplicity' er fellesnevner
                <ul>
                  <li>Lite magi (ikke snakk om DI containers)</li>
                  <li>Minimalisme og lite abstraksjon</li>
                  <li>= en del boilerplate (but its simple)</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <p>Brukes av ...</p>
            <ul>
              <li>Google</li>
              <li>Netflix</li>
              <li>Uber</li>
              <li>Twitch</li>
              <li>Dropbox</li>
              <li>Cloudflare</li>
              <li>Microsoft</li>
              <li>...</li>
            </ul>
          </section>
          <section>
            <p>Typesystem? eks: <a href="https://github.com/go-kit/examples/tree/master/shipping" target="_blank">go-kit - shipping DDD eksempel</a></p>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                type TrackingID string

                // Cargo is the central class in the domain model.
                type Cargo struct {
                    TrackingID         TrackingID
                    Origin             location.UNLocode
                    RouteSpecification RouteSpecification
                    Itinerary          Itinerary
                    Delivery           Delivery
                }
              </code>
            </pre>
            <p class="small">Hvem som helst kan konstruere <b><code>TrackingID</code></b> - "" er gyldig</p>
            <p class="small">Samme gjelder <b><code>Cargo</code></b></p>
          </section>
          <section>
            <pre>
              <code data-trim data-noescape data-line-numbers="*|1-3|5-14|16-22" class="language-golang">
                type trackingID struct {
                    value string
                }

                var ErrEmptyTrackingID = errors.New("empty tracking id")

                func NewTrackingID(value string) (trackingID, error) {
                    if value == "" {
                        return trackingID{}, ErrEmptyTrackingID
                    }
                    return trackingID{
                        value: value,
                    }, nil
                }

                func (id trackingID) String() string {
                    return id.value
                }

                func (id trackingID) Value() string {
                    return id.value
                }

                type Cargo struct {
                    TrackingID trackingID
                }
              </code>
            </pre>
          </section>
          <section>
            <pre>
              <code data-trim data-noescape data-line-numbers class="language-golang">
                func main() {
                    trackingID, err := cargo.NewTrackingID("123")
                    if err != nil {
                        if errors.Is(err, cargo.ErrEmptyTrackingID) {
                            fmt.Println("empty tracking id")
                            return
                        }
                        panic(err)
                    }
                    trackingID2, err := cargo.NewTrackingID("123")
                    if err != nil {
                        if errors.Is(err, cargo.ErrEmptyTrackingID) {
                            fmt.Println("empty tracking id 2")
                            return
                        }
                        panic(err)
                    }

                    // var id shipID = trackingID // Fortunately, this doesn't compile

                    fmt.Printf("tracking id: %s\n", trackingID)              // 123
                    fmt.Printf("tracking id 2: %s\n", trackingID2)           // 123
                    fmt.Printf("are equal: %t\n", trackingID == trackingID2) // true
                    // fmt.Printf("are equal: %t\n", trackingID == "123")    // doesn't compile
                }
              </code>
            </pre>
          </section>
          <section>
            <p>Konklusjon</p>
            <ul>
              <li>DevOps/"teknisk" domene - veldig bra</li>
              <li>God tooling, build perf, simplicity</li>
              <li>
                <a href="https://martinfowler.com/bliki/AnemicDomainModel.html" target="_blank">Anemic domain model</a> og
                <a href="https://refactoring.guru/smells/primitive-obsession" target="_blank">primitive obsession</a>
              </li>
              <li>Kan være tungvindt å enkapsulere (packages er eneste 'boundary')</li>
              <li>Skulle likt å se mer zero-cost og determinisme gitt mye bruk i systems/DevOps</li>
              <hr />
              <li>IMO et steg i riktig retning</li>
            </ul>
          </section>
        </section>
        <section>
          <h3>Databaser</h3>
          <section>
            <ul>
              <li><a href="https://grafana.com/go/webinar/getting-started-with-grafana-lgtm-stack/" target="_blank">Grafana LGTM stack</a></li>
              <li><a href="https://github.com/prometheus/prometheus" target="_blank">Prometheus, Thanos ...</a></li>
              <li><a href="https://github.com/kelindar/column" target="_blank">Column</a></li>
              <li><a href="https://www.cockroachlabs.com/blog/why-go-was-the-right-choice-for-cockroachdb/" target="_blank">Cockroach DB</a></li>
              <li><a href="https://github.com/pingcap/tidb" target="_blank">TiDB</a></li>
              <li><a href="https://github.com/dgraph-io/badger" target="_blank">Badger KV DB</a></li>
              <li><a href="https://github.com/dgraph-io/dgraph" target="_blank">dgraph</a></li>
              <hr />
              <li><a href="https://github.com/hashicorp/memberlist" target="_blank">Memberlist - gossip protocol</a></li>
              <li><a href="https://github.com/hashicorp/raft" target="_blank">Raft - consensus protocol</a></li>
            </ul>
          </section>
          <section>
            <ul>
              <li>Høy kvalitet på biblioteker</li>
              <li>Syscalls og OS APIer veldig godt modellert (for *nix)</li>
              <li>Bra distribution/deployment story</li>
              <li>Definitivt mulig å skrive performant Go</li>
            </ul>
          </section>
        </section>


        <!-- <section>
          <h2>Når <i>bør</i> vi bruke Go?</h2>
          <section>
            <h3>CLIer</h3>
            <ul>
              <li>Lightweight, statically linked binaries</li>
              <li>Rask startup</li>
              <li>Bra biblioteker</li>
            </ul>
          </section>
          <section>
            <h3>Cloud-native</h3>
            <ul>
              <li>Platform-teams</li>
              <li>DevOps</li>
              <li>SRE</li>
              <li>Alt som er tett på containere, k8s</li>
            </ul>
            <p class="fragment fade-up">MEN - WASM anses av mange som "fremtiden", her er det mye Rust</p>
          </section>
          <section>
            <h3>Microservices, backend?</h3>
            <ul>
              <li>Bare min mening</li>
              <li>Ja, hvis greenfield, og man har kompetansen</li>
              <li>Jo mer backend/operasjonelt jo bedre - f. eks. platform teams</li>
              <hr />
              <li>Bra runtime, tooling, ecosystem - men middelmådig typesystem <span style="opacity: 0.6">(til å være et relativt nytt språk)</span></li>
              <li>DDD? "Make invalid states unrepresentable?"</li>
            </ul>
          </section>
        </section> -->

        <section>
          <h2>Performance</h2>
        </section>
        <section>
          <h3>TechEmpower benchmarks - plaintext</h3>
          <section>
            <img src="te-bench-pt-top.png" />
          </section>
          <section>
            <img src="te-bench-pt-chi.png" />
          </section>
        </section>
        <section>
          <h3>TechEmpower benchmarks - fortunes</h3>
          <section>
            <img src="te-bench-fo-top.png" />
          </section>
          <section>
            <img src="te-bench-fo-chi.png" />
          </section>
        </section>
        <section>
          <h3>Performance: <b>generelt</b></h3>
          <ul>
            <li>Tilgang på value types (struct)</li>
            <li>Low latency GC</li>
            <li>Escape analysis gjør at heap allokeringer <i>kan</i> unngås</li>
            <li>Purpose built runtime for concurrency</li>
            <li>Ingen (lett) tilgang til SIMD</li>
            <li>Heller ingen auto-vektorisering?</li>
            <li>Om du trenger interop (cgo) går ting tregt</li>
          </ul>
          <p>
            Stort sett er optimalisering i Go det samme som i alle andre språk:
            unngå dynamisk allokering, cache-friendly datastrukturer, unngå unpredictable branches, unngå virtual calls og polymorphism
          </p>
        </section>

        <section>
          <h2>Over til praktisk...</h2>
        </section>
        <section>
          <h2>Oppsett av go</h2>
          <section>
            <pre class="xxl">
              <code data-noescape class="language-bash">git clone git@github.com:Forse/fagkveld-go.git</code>
            </pre>
            <ul>
              <li>Bruk Linux/Mac (jeg bruker WSL2 Ubuntu) og VSCode</li>
              <li><a href="https://go.dev/doc/install" target="_blank">Installer Go v1.20</a></li> (eksempel finnes i README.md i '/go'-mappa)
              <li>Installer <code>@recommended</code> extensions i VSCode</li>
              <li>
                Go extension i VSCode vil be deg installere noen tools (bl. a. language server).
                <a href="https://github.com/golang/vscode-go/blob/master/docs/tools.md" target="_blank">Gjør det evt manuelt</a> hvis popup ikke dukker opp
              </li>
              <li>Github Copilot for assistert læring</li>
            </ul>
          </section>
        </section>
        <section>
          <h2>Ressurser</h2>
          <section>
            <ul>
              <li><a href="https://boyter.org/posts/how-to-start-go-project-2023/" target="_blank">How to start a Go project in 2023</a> - Ben Boyter</li>
              <li><a href="https://go.dev/learn/" target="_blank">Get Started</a> - go.dev offisiell ressurs</li>
              <li><a href="https://gobyexample.com/" target="_blank">Go by Example</a> - eksempelbasert læring (god referanse)</li>
              <li><a href="https://exercism.org/tracks/go" target="_blank">Go - Exercism</a> - exercism track med 140 oppgaver (interaktivt)</li>
              <hr />
              <li><a href="https://github.com/talent-plan/tinysql">PingCAP talent-plan/TinySQL</a> - et kurs hvor man implementerer en distribuert RDBMS</li>
              <li><a href="https://github.com/talent-plan/tinykv">PingCAP talent-plan/TinyKV</a> - et kurs hvor man implementerer en KV store basert med Raft consensus algo</li>
              <li><a href="https://fly.io/dist-sys/">fly.io Gossip Glomers</a> - distributed systems challenges</li>
            </ul>
          </section>
          <section>
            <p><b><a href="https://exercism.org/dashboard" target="_blank">Exercism</a></b> - lær språk og løs oppgaver i VSCode</p>
            <img style="max-width:75%" src="exercism-helloworld.png" />
          </section>
        </section>
        <section>
          <h2>Referanser</h2>
          <section>
            <ul style="font-size: 2rem">
              <li><a href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" target="_blank">Generics can make your Go code slower</a> - av Planetscale</li>
              <li><a href="https://dusted.codes/how-fast-is-really-aspnet-core" target="_blank">How fast is really ASP.NET Core</a> - av Dustin Morris</li>
              <li><a href="https://www.youtube.com/watch?v=oV9rvDllKEg" target="_blank">Concurrency is not Parallelism</a> - av Rob Pike</li>
              <li><a href="https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/" target="_blank">The cost and complexity of Cgo</a> - av Cockroach Labs</li>
              <li><a href="https://www.cockroachlabs.com/blog/why-go-was-the-right-choice-for-cockroachdb/" target="_blank">Why Go was the right choice for CockroachDB</a></li>
              <li><a href="https://www.youtube.com/watch?v=-K11rY57K7k" target="_blank">Go scheduler: Implementing language with lightweight concurrency</a> - av Dmitry Vyukov</li>
              <li><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank">What color is your function?</a> - av Bob Nystrom</li>
              <li><a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang" target="_blank">Lies we tell ourselves to keep using Golang</a> - av fasterthanlime</li>
              <li><a href="https://github.com/golang/go/wiki/Mobile" target="_blank">Mobile apps in Go</a> - Go docs</li>
              <li><a href="https://github.com/tinygo-org/tinygo" target="_blank">TinyGo</a></li>
              <li><a href="https://eli.thegreenplace.net/2019/go-compiler-internals-adding-a-new-statement-to-go-part-1/" target="_blank">Go compiler internals</a> - av Eli Bendersky</li>
              <li><a href="https://medium.com/servicetitan-engineering/go-vs-c-part-2-garbage-collection-9384677f86f1" target="_blank">Go vs C#, part 2: Garbage Collection</a> - av Alex Yakunin</li>
              <li><a href="https://www.datadoghq.com/blog/engineering/introducing-glommio/" target="_blank">Introducing Glommio, a Thread-per-Core Crate for Rust & Linux</a> - av Glauber Costa</li>
              <li><a href="https://www.uber.com/en-NO/blog/how-we-saved-70k-cores-across-30-mission-critical-services/" target="_blank">How We Saved 70K Cores Across 30 Mission-Critical Services</a> - av Uber</li>
              <li><a href="https://menno.io/posts/golang-register-calling/" target="_blank">Faster software through register based calling</a> - menno</li>
            </ul>
          </section>
        </section>
      </div>
    </div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
